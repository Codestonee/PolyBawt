"""
Exchange Simulator for PolyBawt.

Simulates Polymarket CLOB behavior for deterministic replay:
- Price-time priority matching
- Post-only order enforcement
- Dynamic fee curve application
- Tick size and minimum order constraints
- Fill generation with realistic latency

Usage:
    sim = ExchangeSimulator()
    sim.place_order(order)
    fills = sim.match_order(taker_order)
"""

from __future__ import annotations
import time
from dataclasses import dataclass, field
from typing import Dict, List, Optional, Tuple
from enum import Enum
from collections import defaultdict
from sortedcontainers import SortedList
import heapq

from src.risk.fees import taker_fee_rate, estimated_maker_rebate_rate
from src.infrastructure.logging import get_logger

logger = get_logger(__name__)


# Constants
TICK_SIZE = 0.01  # Default tick size
MIN_ORDER_SIZE = 0.01  # Minimum order size


class OrderSide(Enum):
    BUY = "BUY"
    SELL = "SELL"


class OrderType(Enum):
    LIMIT = "LIMIT"
    POST_ONLY = "POST_ONLY"
    IOC = "IOC"  # Immediate or Cancel


class OrderStatus(Enum):
    NEW = "NEW"
    OPEN = "OPEN"
    PARTIALLY_FILLED = "PARTIALLY_FILLED"
    FILLED = "FILLED"
    CANCELED = "CANCELED"
    REJECTED = "REJECTED"


@dataclass
class SimOrder:
    """Order in the simulated exchange."""
    order_id: str
    token_id: str
    side: OrderSide
    price: float
    original_size: float
    remaining_size: float
    order_type: OrderType = OrderType.LIMIT
    status: OrderStatus = OrderStatus.NEW
    timestamp_ns: int = field(default_factory=lambda: time.time_ns())
    
    @property
    def is_buy(self) -> bool:
        return self.side == OrderSide.BUY
    
    @property
    def filled_size(self) -> float:
        return self.original_size - self.remaining_size


@dataclass
class SimFill:
    """Fill generated by the simulator."""
    fill_id: str
    order_id: str
    token_id: str
    side: OrderSide
    price: float
    size: float
    is_maker: bool
    fee_paid: float
    rebate_est: float
    timestamp_ns: int = field(default_factory=lambda: time.time_ns())
    match_order_id: Optional[str] = None  # The order we matched against


class OrderBook:
    """
    Simulated order book with price-time priority.
    
    Bids sorted by price DESC, then time ASC (highest price, earliest first)
    Asks sorted by price ASC, then time ASC (lowest price, earliest first)
    """
    
    def __init__(self, token_id: str, tick_size: float = TICK_SIZE):
        self.token_id = token_id
        self.tick_size = tick_size
        
        # Orders indexed by order_id
        self._orders: Dict[str, SimOrder] = {}
        
        # Price levels: price -> list of order_ids in time priority
        self._bids: Dict[float, List[str]] = defaultdict(list)
        self._asks: Dict[float, List[str]] = defaultdict(list)
        
        # Sorted price levels for quick best bid/ask
        self._bid_prices: List[float] = []  # Max heap (negated)
        self._ask_prices: List[float] = []  # Min heap
        
        self._fill_counter = 0
    
    @property
    def best_bid(self) -> Optional[float]:
        while self._bid_prices:
            price = -self._bid_prices[0]
            if self._bids.get(price):
                return price
            heapq.heappop(self._bid_prices)
        return None
    
    @property
    def best_ask(self) -> Optional[float]:
        while self._ask_prices:
            price = self._ask_prices[0]
            if self._asks.get(price):
                return price
            heapq.heappop(self._ask_prices)
        return None
    
    @property
    def spread(self) -> Optional[float]:
        bid, ask = self.best_bid, self.best_ask
        if bid is not None and ask is not None:
            return ask - bid
        return None
    
    @property
    def midpoint(self) -> Optional[float]:
        bid, ask = self.best_bid, self.best_ask
        if bid is not None and ask is not None:
            return (bid + ask) / 2
        return None
    
    def add_order(self, order: SimOrder) -> bool:
        """
        Add order to book.
        
        Returns:
            True if added, False if rejected (e.g., post-only crossing)
        """
        # Round price to tick
        order.price = round(order.price / self.tick_size) * self.tick_size
        
        # Post-only check: reject if would cross
        if order.order_type == OrderType.POST_ONLY:
            if order.is_buy and self.best_ask and order.price >= self.best_ask:
                order.status = OrderStatus.REJECTED
                return False
            if not order.is_buy and self.best_bid and order.price <= self.best_bid:
                order.status = OrderStatus.REJECTED
                return False
        
        # Add to book
        self._orders[order.order_id] = order
        order.status = OrderStatus.OPEN
        
        if order.is_buy:
            self._bids[order.price].append(order.order_id)
            heapq.heappush(self._bid_prices, -order.price)
        else:
            self._asks[order.price].append(order.order_id)
            heapq.heappush(self._ask_prices, order.price)
        
        return True
    
    def cancel_order(self, order_id: str) -> bool:
        """Cancel an order."""
        order = self._orders.get(order_id)
        if not order or order.status not in (OrderStatus.OPEN, OrderStatus.PARTIALLY_FILLED):
            return False
        
        order.status = OrderStatus.CANCELED
        
        # Remove from price level
        price_level = self._bids if order.is_buy else self._asks
        if order.price in price_level:
            try:
                price_level[order.price].remove(order_id)
            except ValueError:
                pass
        
        return True
    
    def match_taker(self, taker: SimOrder) -> List[SimFill]:
        """
        Match a taker order against resting orders.
        
        Returns list of fills generated.
        """
        fills = []
        
        while taker.remaining_size > 0:
            # Get best opposing level
            if taker.is_buy:
                best_price = self.best_ask
                levels = self._asks
            else:
                best_price = self.best_bid
                levels = self._bids
            
            if best_price is None:
                break
            
            # Check if taker crosses
            if taker.is_buy and taker.price < best_price:
                break
            if not taker.is_buy and taker.price > best_price:
                break
            
            # Match against orders at this level
            while levels.get(best_price) and taker.remaining_size > 0:
                maker_id = levels[best_price][0]
                maker = self._orders.get(maker_id)
                
                if not maker or maker.remaining_size <= 0:
                    levels[best_price].pop(0)
                    continue
                
                # Calculate fill size
                fill_size = min(taker.remaining_size, maker.remaining_size)
                
                # Generate fills
                self._fill_counter += 1
                fill_id = f"fill_{self._fill_counter}"
                
                # Calculate fees
                # Probability approximation from price
                prob = best_price if taker.is_buy else (1 - best_price)
                prob = max(0.01, min(0.99, prob))
                
                taker_fee = fill_size * taker_fee_rate(prob)
                maker_rebate = fill_size * estimated_maker_rebate_rate(prob)
                
                # Taker fill
                fills.append(SimFill(
                    fill_id=f"{fill_id}_taker",
                    order_id=taker.order_id,
                    token_id=self.token_id,
                    side=taker.side,
                    price=best_price,
                    size=fill_size,
                    is_maker=False,
                    fee_paid=taker_fee,
                    rebate_est=0.0,
                    match_order_id=maker_id,
                ))
                
                # Maker fill
                fills.append(SimFill(
                    fill_id=f"{fill_id}_maker",
                    order_id=maker_id,
                    token_id=self.token_id,
                    side=maker.side,
                    price=best_price,
                    size=fill_size,
                    is_maker=True,
                    fee_paid=0.0,
                    rebate_est=maker_rebate,
                    match_order_id=taker.order_id,
                ))
                
                # Update sizes
                taker.remaining_size -= fill_size
                maker.remaining_size -= fill_size
                
                # Update statuses
                if maker.remaining_size <= 0:
                    maker.status = OrderStatus.FILLED
                    levels[best_price].pop(0)
                else:
                    maker.status = OrderStatus.PARTIALLY_FILLED
                
                if taker.remaining_size <= 0:
                    taker.status = OrderStatus.FILLED
                else:
                    taker.status = OrderStatus.PARTIALLY_FILLED
        
        return fills
    
    def get_depth(self, side: OrderSide, levels: int = 5) -> List[Tuple[float, float]]:
        """Get order book depth (price, total_size) for N levels."""
        result = []
        
        if side == OrderSide.BUY:
            prices = sorted(self._bids.keys(), reverse=True)[:levels]
            for price in prices:
                total = sum(
                    self._orders[oid].remaining_size
                    for oid in self._bids[price]
                    if oid in self._orders
                )
                if total > 0:
                    result.append((price, total))
        else:
            prices = sorted(self._asks.keys())[:levels]
            for price in prices:
                total = sum(
                    self._orders[oid].remaining_size
                    for oid in self._asks[price]
                    if oid in self._orders
                )
                if total > 0:
                    result.append((price, total))
        
        return result


class ExchangeSimulator:
    """
    Simulated Polymarket exchange for deterministic replay.
    
    Features:
    - Multiple order books (one per token)
    - Price-time priority matching
    - Post-only enforcement
    - Dynamic fee calculation
    - Latency injection (configurable)
    """
    
    def __init__(
        self,
        tick_size: float = TICK_SIZE,
        min_order_size: float = MIN_ORDER_SIZE,
        ack_delay_ns: int = 50_000_000,  # 50ms default
    ):
        self.tick_size = tick_size
        self.min_order_size = min_order_size
        self.ack_delay_ns = ack_delay_ns
        
        self._books: Dict[str, OrderBook] = {}
        self._order_counter = 0
        self._fills: List[SimFill] = []
    
    def get_book(self, token_id: str) -> OrderBook:
        """Get or create order book for token."""
        if token_id not in self._books:
            self._books[token_id] = OrderBook(token_id, self.tick_size)
        return self._books[token_id]
    
    def place_order(
        self,
        order_id: str,
        token_id: str,
        side: str,
        price: float,
        size: float,
        order_type: str = "LIMIT",
    ) -> Tuple[SimOrder, List[SimFill]]:
        """
        Place an order in the simulator.
        
        Returns:
            Tuple of (order, list of fills if any)
        """
        if size < self.min_order_size:
            order = SimOrder(
                order_id=order_id,
                token_id=token_id,
                side=OrderSide(side),
                price=price,
                original_size=size,
                remaining_size=size,
                order_type=OrderType(order_type),
                status=OrderStatus.REJECTED,
            )
            return order, []
        
        order = SimOrder(
            order_id=order_id,
            token_id=token_id,
            side=OrderSide(side),
            price=price,
            original_size=size,
            remaining_size=size,
            order_type=OrderType(order_type),
        )
        
        book = self.get_book(token_id)
        fills = []
        
        # IOC orders try to fill immediately
        if order.order_type == OrderType.IOC:
            fills = book.match_taker(order)
            if order.remaining_size > 0:
                order.status = OrderStatus.CANCELED
            self._fills.extend(fills)
            return order, fills
        
        # Post-only or limit orders
        if order.order_type == OrderType.POST_ONLY:
            if not book.add_order(order):
                return order, []  # Rejected
            return order, []
        
        # Regular limit: try to fill then rest
        fills = book.match_taker(order)
        self._fills.extend(fills)
        
        if order.remaining_size > 0:
            book.add_order(order)
        
        return order, fills
    
    def cancel_order(self, token_id: str, order_id: str) -> bool:
        """Cancel an order."""
        book = self.get_book(token_id)
        return book.cancel_order(order_id)
    
    def get_best_bid(self, token_id: str) -> Optional[float]:
        return self.get_book(token_id).best_bid
    
    def get_best_ask(self, token_id: str) -> Optional[float]:
        return self.get_book(token_id).best_ask
    
    def get_midpoint(self, token_id: str) -> Optional[float]:
        return self.get_book(token_id).midpoint
    
    def get_all_fills(self) -> List[SimFill]:
        """Get all fills generated during simulation."""
        return self._fills.copy()
    
    def reset(self):
        """Reset simulator state."""
        self._books.clear()
        self._fills.clear()
        self._order_counter = 0
